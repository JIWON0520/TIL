## 산탄데르 고객 만족 예측

캐글의 산탄데르 고객 만족 예측 데이터 세트에 대해서 고객 만족 여부를 XGBoost와 LightGBM을 활용해 예측해 보자.

산탄데르 고객 만족 예측 분석은 370개의 피처로 주어진 데이터 세트를 기반에서 고객 만족 여부를 예측하는 것이다. 클레스 레이블 명은 Target이며 이 값이 1이면 불만을 가진 고객, 0이면 만족한 고객이다. 모델의 성능 평가는 ROC-AUC로 평가한다. 대부분이 만족이고 일부분이 불만족 데이터 일것이므로 정확도 보다는 ROC-AUC가 더 적합하다.

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib

cust_df=pd.read_csv("/content/drive/MyDrive/Colab Notebooks/santander countomer satisfaction/train.csv",encoding='latin-1')
print('dataset shape:',cust_df.shape)
cust_df.head(3)
```

[output]

![결과1](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/58c2e510-dc11-4ef2-9020-c8194b3bcf62/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210608%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210608T152354Z&X-Amz-Expires=86400&X-Amz-Signature=5ba4f51b34e20f91469ddad6696264bd0b6cb6a62d576c26b5b45d87f3f34148&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)

클래스 값을 포함해서 371개의 피쳐값이 존재한다.

피처의 타입과 NULL값을 알아보자.

```python
cust_df.info()
```

[output]

![결과2](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/cb48fb86-1fa7-4326-a46a-0ad0813bda98/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210608%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210608T152437Z&X-Amz-Expires=86400&X-Amz-Signature=92fdfbeb214912a0be0d124008d7815f4eb87b1829d3b3dd76dc60c6a1f0542c&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)

피처의 타입은 모두 숫자형이고 NULL값은 없다.

전체 데이터에서 만족과 불만족의 비율을 살펴보자.

```python
print(cust_df["TARGET"].value_counts())
unsatisfied_cnt=cust_df[cust_df['TARGET']==1].TARGET.count()
total_cnt=cust_df.TARGET.count()
print('unsatisfied 비율은 {0:.2f}'.format((unsatisfied_cnt/total_cnt)))
```

[output]

![결과3](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/2d6ab6a2-1c32-4b6a-93b5-58e1aad03c4e/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210608%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210608T152545Z&X-Amz-Expires=86400&X-Amz-Signature=9fae3b7a7a16674f2264f52da4c1a5718fe76a583b95ae97ae06766cceb362bb&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)

대부분이 만족이며 불만족인 고객은 얼마 되지 않는4%에 불과하다.

```python
cust_df.describe()
```

[output]

![결과4](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/29832a79-dd25-42b4-818d-036ab0725217/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210608%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210608T152620Z&X-Amz-Expires=86400&X-Amz-Signature=1a834f99ff8c52d477c7596de29f54394be546a657271bc6a3c1b2d0da19201b&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)

피처들중 var3을 보면 min값이 -999999이다. 특정 예외값을 -999999로 변환했을 것이다.

```python
print(cust_df.var3.value_counts()[:10])
```

[output]

![결과5](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/04251259-5dd2-4eef-8250-d13eeed84245/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210608%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210608T152654Z&X-Amz-Expires=86400&X-Amz-Signature=c7946a747eeb068c10c038bfb929cb6af823b0e80cf7c1c4a4f6bd7cd8516b1a&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)

실제로 위의 출력 결과를 보면 -999999값이 116개나 있음을 알 수 있다. -999999값을 가장 많은 2로 변환하겠다. 또한 ID피처는 단순 식별자에 불과하므로 삭제하겠다.

```python
cust_df['var3'].replace(-999999,2,inplace=True)
cust_df.drop('ID',axis=1,inplace=True)

#피처세트와 레이블 세트 분리. 레이블 칼럼은 DataFrame의 맨 마지막에 위치해 칼럼 위치 -1로분리
X_featrue=cust_df.iloc[:,:-1]
y_labels=cust_df.iloc[:,-1]
print('피처 데이터 shape:{0}'.format(X_fearue.shape))
```

[output]

![결과6](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/bd92823a-1e8e-474f-a88d-4f79c61c4dfa/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210608%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210608T152819Z&X-Amz-Expires=86400&X-Amz-Signature=042cc5caaa76eb2d3ffea1e6522ee13a7846b69fc68dddb3172a28aad1b5c4ad&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)

학습과 성능 평가를 위해서 원본 데이터 세트에서 학습 데이터 세트와 테스트 데이터 세트를 분리하겠다. 비대칭한 데이터 세트이므로 클래스인 Target값 분포도가 학습데이터와 테스트 데이터세트에 모두 비슷하게 추출되었는지 확인도하자.

```python
from sklearn.model_selection import train_test_split

X_train,X_test,y_train,y_test=train_test_split(X_feature,y_labels,test_size=0.2,random_state=0)

train_cnt=y_train.count()
test_cnt=y_test.count()
print('학습 세트 Shape:{0}, 테스트 세트 Shape:{1}'.format(X_train.shape,X_test.shape))

print('학습 세트 레이블 분포 비율')
print(y_train.value_counts()/train_cnt)
print('테스트 세트 레이블 분포 비율')
print(y_test.value_counts()/test_cnt)
```

[output]

![결과7](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/5cd1f2c9-8333-47ae-95a9-58a3f1657be9/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210608%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210608T152936Z&X-Amz-Expires=86400&X-Amz-Signature=15cf98abcc097cb923be3e41e206637d13da3dcff67f2cbef37d77b0811c4b59&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)

학습과 테스트 데이터 세트 모두 Target값의 분포가 원본 데이터와 유사하게 전체 데이터의 4%정도의 불만족 겂으로 만들어졌다.

### XGBoost 모델 학습과 하이퍼 파라미터 튜닝

XGBoost를 이용하여 학습과 테스트를 진행해 보자.

```python
from xgboost import XGBClassifier
from sklearn.metrics import roc_auc_score

#n_estimators는 500으로, random state는 예제 수행 시마다 동일 예측 결과를 위해 설정.
xgb_clf=XGBClassifier(n_estimators=500, random_state=0)

#성능 평가 지표를 auc로, 조기 중단 파리미터는 100으로 설정하고 학습 수행
xgb_clf.fit(X_train,y_train, early_stopping_rounds=100, eval_metric="auc",eval_set=[(X_train,y_train),(X_test,y_test)])

xgb_roc_score=roc_auc_score(y_test,xgb_clf.predict_proba(X_test)[:,1],average='macro')
print('ROC AUC:{0:.4f}'.format(xgb_roc_score))
```

[output]

![결과8](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/4516b93a-6905-422a-9033-76e4153497fc/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210608%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210608T153049Z&X-Amz-Expires=86400&X-Amz-Signature=7c7c5b7ec59399e8514987bde705b7dd4c08e22a6f8babdf7c17cc108b687311&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)

....

![결과9](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/60d5a061-4fed-46bc-ac77-70e26b132da6/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210608%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210608T153103Z&X-Amz-Expires=86400&X-Amz-Signature=77a92b819e53c36c6cd3a8e0ae6872c26ad9b1285b98fed2085f2542ec9e201a&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)

178번 반복하고 조기종료 하였다. 테스트 데이터로 예측시 ROC AUC는 약 0.8419이다

다음으로 XGBoost의 하이퍼 파라미터를 튜닝해보자.

```python
from sklearn.model_selection import GridSearchCV

#하이퍼 파라미터 테스트의 수행 속도를 향상시키기 위해 n_estimators를 100으로 감소
xgb_clf=XGBClassifier(n_estimators=100, random_state=0)

params={'max_depth':[5,7],'min_child_wegiht':[1,3],'colsample_bytree':[0.5,0.75]}

#cv는 3으로 지정
grid_cv=GridSearchCV(xgb_clf, param_grid=params, cv=3)
grid_cv.fit(X_train,y_train,early_stopping_rounds=30,eval_metric='auc',eval_set=[(X_train,y_train),(X_test,y_test)])

print('GridSearchCV 최적 파라미터:',grid_cv.best_params_)

xgb_roc_auc=roc_auc_score(y_test,grid_cv.predict_proba(X_test)[:,1],average='macro')
print('ROC AUC:{0:.4f}'.format(xgb_roc_score))
```

[output]

![결과10](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/7e4f2ead-96da-4b67-943f-21e2f6d7322c/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210608%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210608T153123Z&X-Amz-Expires=86400&X-Amz-Signature=251ba5b7136fcea4848b6f2428ca4339a3c055d00e2a7b59f8db91e4b8b1a64f&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)

하이퍼 파라미터 colsample_bytree가 0.5, max_depth가 5, min_child_wegiht가 1일 때, ROC AUC가 약 0.8461로 개선되었다.

마지막으로 각 피처의 중요도를 피처 중요도 그래프로 나타내보자.

```python
xgb_roc_auc=roc_auc_score(y_test,grid_cv.predict_proba(X_test)[:,1],average='macro')
print('ROC AUC:{0:.4f}'.format(xgb_roc_auc))
```

[output]

![결과11](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/a9a733ce-c8c9-4050-97c4-470fc1078acc/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210608%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210608T153202Z&X-Amz-Expires=86400&X-Amz-Signature=3644f027207300bc817ee26867b7851a450c0f3739066bd0f70fc74a0c9caea0&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)

### LightGBM 모델 학습과 하이퍼 파라미터 튜닝

앞의 예제 코드에서 만들어진 데이터 세트를 기반으로 LightGBM으로 학습을 수행하고, ROC-AUC를 측정해 보자.

```python
from lightgbm import LGBMClassifier

lgbm_clf=LGBMClassifier(n_estinators=500)

evals=[(X_test,y_test)]
lgbm_clf.fit(X_train,y_train,early_stopping_rounds=100, eval_metric='auc',eval_set=evals, verbose=True)

lgbm_roc_score=roc_auc_score(y_test,lgbm_clf.predict_proba(X_test)[:,1],average='macro')
print('ROC AUC:{0:.4f}'.format(lgbm_roc_score))
```

[output]

![결과12](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/dd06250d-bf78-484c-b90b-93c802bfc45b/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210608%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210608T153224Z&X-Amz-Expires=86400&X-Amz-Signature=865cc163c2f705a8c4aede2221ffe33450a6cdf3d3d351db794acae0db9782a3&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)

LightGBM 수행 결과 ROC AUC가 약 0.8396을 나타낸다.

이번에는 GirdSearchCV로 하이퍼 파라미터 튜닝을 수행해 보자.

```python
#하이퍼 파라미터 테스트의 수행 속도를 향상시키기 위해 n_estimators를 200으로 감소
lgbm_clf=LGBMClassifier(n_estimators=200)

params={'num_leaves': [32,64],
        'max_depth':[128,160],
        'min_child_samples':[60,100],
        'subsample':[0.8,1]}

#cv는 3으로 지정
grid_cv=GridSearchCV(lgbm_clf,param_grid=params,cv=3)
grid_cv.fit(X_train,y_train, early_stopping_rounds=30, eval_metric='auc', eval_set=evals)

print("GridSearchCV 최적 하이퍼 파라미터:",grid_cv.best_params_)
lgbm_roc_score=roc_auc_score(y_test,grid_cv.predict_proba(X_test)[:,1],average='macro')
print("ROC AUC:{0:.4f}".format(lgbm_roc_score))
```

[output]

![결과13](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/97d2cf6c-6624-4457-8572-735c00b9d21d/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210608%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210608T153250Z&X-Amz-Expires=86400&X-Amz-Signature=ad27a3b55f77c5c43d9b73de99eb6d2d57337a690f23019bb1a4a7fcb90d0028&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)

해당 하이퍼 파라미터를 LightGBM에 적용하고 다시 학습해 ROC-AUC 측정 결과를 도출해 보자.

```python
lgbm_clf=LGBMClassifier(n_estimators=1000, num_leaves=32,max_depth=128,min_child_samples=100,subsample=0.8)

lgbm_clf.fit(X_train,y_train,early_stopping_rounds=100, eval_metric='auc',eval_set=evals,verbose=True)

lgbm_roc_score=roc_auc_score(y_test,lgbm_clf.predict_proba(X_test)[:,1], average='macro')
print("ROC AUC:{0:.4f}".format(lgbm_roc_score))
```

[output]

![결과14](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/a6fed27d-4e84-4724-8c39-50d4686eeee2/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210608%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210608T153329Z&X-Amz-Expires=86400&X-Amz-Signature=611676e2d16249980ff44828dc5d910a4f445dd4e1adf7de6818c51e07b20c98&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)

LightGBM의 경우 테스트 데이터 세트에서 ROC-AUC가 약 0.8442로 측정되었다.
